#define SPEED_NORMAL 45
#define SPEED_TURN 10
#define THRESHOLD 50

#define TURN_LEFT 0
#define TURN_RIGHT 1
#define TURN_NONE 2

#define T_INTERSECTION 0
#define CROSS_INTERSECTION 1

//What to do when it reaches an intersection.
int turnChoice = TURN_NONE;

//What type of intersection is coming up ahead.
//Must be set correctly to allow proper turning!
int intersectionType = CROSS_INTERSECTION;

//This flag is set to true whenever a turn is made.
bool hasMadeTurn;

//flag for the LineFollow task to stop.
//when false, stop the task.
bool continueLineFollow;

//Set the line following routine to go straight or turn left or right when it reaches an intersection.
//The intersection type must be properly set for the robot to be able to turn properly.
//call with one of TURN_*
void SetTurnChoice(int choice){
	turnChoice = choice;
}

//Set the the pattern of the next intersection. 
//This must be set properly to allow the robot to turn correctly.
//Only supports T and 4-way intersections at the moment.
//Cal with *_INTERSECTION
void SetIntersectionType(int type){
	intersectionType = type;
}

//Helper function.
//Forces the current thread to wait until the sensor at the given port detects
//that it is on a black line.
void WaitUntilBlack(int port){
	bool black = Sensor(port) < THRESHOLD;
	while (!black){
		black  = Sensor(port) < THRESHOLD;
		Wait(50);
	}
}

//Helper Function.
//Forces the current thread to wait until a turn has been completed.
void WaitUntilTurn(){
	hasMadeTurn = false;
	while (!hasMadeTurn){
		Wait(50);
	}
}

task lineFollow(){
	hasMadeTurn = false;
	SetSensorLight(S3);//right
	SetSensorLight(S4);//left
	//a right, c left
	OnFwd(OUT_AC, SPEED_NORMAL);
	while (continueLineFollow){
		ResetScreen();
		int right = Sensor(S3);
		int left = Sensor(S4);

		NumOut(0,LCD_LINE1, left);

		NumOut(0,LCD_LINE2, right);

		bool leftOnLine = left < THRESHOLD;
		bool rightOnLine = right < THRESHOLD;

		if (leftOnLine && rightOnLine && turnChoice != TURN_NONE && continueLineFollow){			
			Wait(400);
			if (turnChoice == TURN_LEFT){
				OnRev(OUT_C, SPEED_NORMAL - 10 );
				OnFwd(OUT_A, SPEED_NORMAL + 15);
				while (leftOnLine || rightOnLine){
					Wait(50);
					leftOnLine = Sensor(S4) < THRESHOLD;
					rightOnLine = Sensor(S3) < THRESHOLD;
				}
				if (intersectionType == CROSS_INTERSECTION){
					WaitUntilBlack(S3);
					WaitUntilBlack(S4);
					WaitUntilBlack(S3);
				}else if (intersectionType == T_INTERSECTION){
					WaitUntilBlack(S4);
					WaitUntilBlack(S3);
				}
				hasMadeTurn = true;
			}else if (turnChoice == TURN_RIGHT){
				OnRev(OUT_A, SPEED_NORMAL - 10 );
				OnFwd(OUT_C, SPEED_NORMAL + 15);
				while (leftOnLine || rightOnLine){
					Wait(50);
					leftOnLine = Sensor(S4) < THRESHOLD;
					rightOnLine = Sensor(S3) < THRESHOLD;
				}
				if (intersectionType == CROSS_INTERSECTION){
					WaitUntilBlack(S4);
					WaitUntilBlack(S3);
					WaitUntilBlack(S4);
				}else if (intersectionType == T_INTERSECTION){
					WaitUntilBlack(S3);
					WaitUntilBlack(S4);
				}
				hasMadeTurn = true;
			}
		}else if (leftOnLine){
			OnFwd(OUT_C, SPEED_TURN);
			while (Sensor(S4) < THRESHOLD && Sensor(S3) > THRESHOLD){
				Wait(50);
			}
		}else if (rightOnLine){
			OnFwd(OUT_A, SPEED_TURN);
			while (Sensor(S3) < THRESHOLD && Sensor(S4) > THRESHOLD){
				Wait(50);
			}
		}
		OnFwd(OUT_AC, SPEED_NORMAL);
	}
}

//Starts the line following task.
//This controls the motors on OUT_AC (left = C, right = A) so once this is running you should not interact with those motors
//directly. Otherwise it immediately returns and you can continue running code while the line following task runs in
//another thread.
void StartLineFollow(){
	continueLineFollow = true;
	start lineFollow;
}

//This function ends the line following task.
//It forces the current thread to wait 455 milliseconds so that the task terminates before it returns.
void StopLineFollow(){
	continueLineFollow = false;
	Wait(455);
}

task main(){
	SetTurnChoice(TURN_LEFT);
	SetIntersectionType(T_INTERSECTION);
	StartLineFollow();
	WaitUntilTurn();
	WaitUntilTurn();
	SetIntersectionType(CROSS_INTERSECTION);
	WaitUntilTurn();
	SetTurnChoice(TURN_RIGHT);
	WaitUntilTurn();
	StopLineFollow();
}
